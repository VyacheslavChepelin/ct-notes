#import "../template.typ":*

= Лекция 2 

== Деревья
#definition(
  title: [Дерево],
  body: [Дерево --- связный неориентированный граф без циклов]
)
#theorem(
  name:[Лемма],
  body:[
   $G$ --- дерево, содержащее хотя бы 2 вершины. Тогда $exists$ вершина степени 1.
 ])

 Ее можно усилить до того, что существуют 2 таких вершины. Такие вершины называются *висячими* или *листами*  .

#theorem(
  body:[
   $G$ --- граф, содержит $n$ вершин.
  1. $n-1$ ребер
  2. нет циклов
  3. $G$ --- связный
  Если выполнены любые 2 из данных 3, то выполнено и третье]
)
Доказательство этой теоремы очень просто

#theorem(
  body:[
   $G$ --- дерево тогда и только тогда, когда $forall u,v: exists!$ простой путь $u arrow.squiggly v$],
)
Доказательство этой теоремы тоже очень просто: стоит лишь рассмотреть от противного.

#def[Утверждение.] $G$ дерево $<=> G$ связен и любое ребро мост.

#definition(title:[Подграф],
body:[$G$ - граф. $H$ получен удалением из $G$ ребер или вершин. $H$ называется подграфом $G$])

#definition(title:[Индуцированный Подграф],
body:[$G$ - граф. $H$ получен удалением из $G$ вершин.  $H$ называется индуцированным подграфом $G$])

#definition(title:[Остовный Подграф],
body:[$G$ - граф. $H$ получен удалением из $G$ ребер, причем $H$ связно.  $H$ называется остовным подграфом $G$])

#definition(title:[Остовное дерево],
body:[Остовное дерево - остовный граф, который является деревом])

#theorem(
  name:[Лемма],
  body:[
   Любой связный граф содержит остовное дерево
 ])

 #definition(title:[Матрица Кирхгофа],
body:[Матрица Кирхгофа называется матрица $K_G$,такая что 
$ a_(i j) =cases(deg i\,i = j, -1\, i j in E, 0 " иначе") $])

#theorem(title:[Кирхгофа],body:[$G$ - связный граф. Кол-во остовных деревьев $G $ равно  $ overline(A_(i j)), forall i,j$],
proof:[

  #def[Лемма 1.]
  
  Введем понятие для графа $G$ *матрицы инцидентов*. Пусть у нас $n$ вершин и $m$ ребер. Возьмем матрицу из $m$ столбцов и $n$ строк и для каждого ребра в этой матрице инцидентов поставим 1 в соотв. строку если ребро соединяет эту вершину с другой и 0 иначе. Назовем ее $I_g$. Пример:

  #align(center)[#image("../assets/2-incident-matrix.png", width:60%)]

  Возьмем $I_g$ и $I_g^T$ и перемножим. Заметим, что получится матрица Кирхгофа, но у нас не того знака единицы.  Возьмем теперь ориентацию графа $G$ (любую). Поставим -1 в начало ребра и +1 в конец. Теперь уже перемножая их получим нашу нужную нам матрицу Кирхгофа.
  $ arrow(I)_n * arrow(I)_n^T =  "Матрица Киргофа G" $

  #def[Лемма 2.]
  
  Давайте выберем любое $n-1$ ребро. Рассмотрим столбцы $arrow(I)_n$, связанные с этими ребрами. Удалим любую строчку. Останется матрица $n-1$ на $n-1$. Назовем ее $B$. 
  Если выбранные ребра образуют остовное дерево, то $det B  =plus.minus 1$, иначе $det B = 0$.
  
  #def[Доказательство:]
  
  Обозначим множество оставшихся рёбер за $E Q$, а вершину, которую мы вычеркнули,~--- за $u$.
        
            - Если $E Q$ содержит цикл, то граф, тривиально, не связен. Рассмотрим компоненту связности, не содержащую $u$. В ней сумма столбцов равна нулю, и хорошо. Ну, как хорошо. Вообще $E Q$ может не содержать ориентированного цикла, но содержать цикл $G$. Так вот, в таком случае нам придётся взять не сумму соответствующих столбцов, а алгебраическую сумму, где неправильно направленные рёбра идут с коэффициентом $-1$. Тогда мы получим-таки наш ноль, то есть линейная комбинация столбцов будет равна нулю, следовательно определитель нулевой.
            - Теперь пусть циклов там нет. Тогда там дерево (нет циклов и $n-1$ ребро). Оно содержит 2 листа. Один из них~--- не $u$. Обзовём его $v_1$. Поскольку мы считаем определок, нам разрешают переставлять строки и столбцы матрицы: давайте возьмём строку $v_1$, в ней где-то ровно одна $plus.minus 1$. Переместим строку на первое место, а $plus.minus 1$~--- в первый столбец, после чего забудем о $v_1$. Оставшаяся часть~--- дерево, в нём есть два листа, один~--- не $u$, возьмём его как $v_2$. Так сделаем до посинения, получим нижне-треугольную матрицу с $plus.minus 1$ на диагонали.
#def[Лемма 3. Формула Коши-Бине] 

  Пусть $A$~--- матрица $r times s$, $B$~--- матрица $s times r$, $s >= r$. Тогда
        $
        det(A B) = limits(sum)_(1<= i_1<= i_2<= ...<= i_r<= s)det A^(i_1;...;i_r)det B_(i_1;...;i_r)
        $
        Напомню, что $A^(i_1;...;i_r)$~--- минор матрицы $A$, где выбраны столбцы $i_1;...;i_r$, а $B_(i_1;...;i_r)$~--- минор $B$,  где выбраны строки $i_1;...;i_r$.
        
        
        Доказывать формулу мы не будем. Кучерук нам вроде даже ее давала


#def[Наконец доказательство самой теоремы]

Вычеркнем строчку с номером $u$. Что изменится в матрице Кирхгофа? Удалится строчка и столбец с $u$.

А теперь, используя формулу Коши-Бине для подсчета данного минора. Ой смотрим смотрим и получаем, что количество остовных деревьев в точности равно нашему минору.


])


== Коды Прюфера (для неориентированных деревьев)

Коды Прюфера — это способ установить *биекцию* между помеченными деревьями и числовыми последовательностями. 

*Исходные данные:*
*   Рассматриваем *деревья на `n` вершинах*, помеченных числами от `1` до `n`.
*   Дерево — это связный граф без циклов.

*Алгоритм кодирования (преобразование дерева в код Прюфера)*

Цель: получить последовательность (код) длиной `n-2`.

1.  Пусть `T` — наше дерево с множеством вершин `{1, 2, ..., n}`.
2.  Пока в дереве больше двух вершин, повторяем следующие шаги:
    a.  Найдите *лист*  с *наименьшим номером*.
    b.  Запишите в код Прюфера номер *единственной вершины, смежной* с этим листом (его "соседа").
    c.  *Удалите этот лист* и инцидентное ему ребро из дерева `T`.
3.  Когда останется всего 2 вершины, процесс останавливается. Полученная запись — это *код Прюфера* для дерева `T`.


*Алгоритм декодирования (преобразование кода Прюфера в дерево)*

Цель: по последовательности длиной `n-2` восстановить дерево на `n` вершинах.

1.  Пусть дан код Прюфера `P` длиной `n-2`. Постройте список вершин `L = {1, 2, ..., n}`.
2.  Пока код `P` не пуст, повторяйте:
    1.  Найдите *наименьший номер* из списка `L`, который *не встречается* в коде `P`. Этот номер будет листом.
    2.  *Проведите ребро* из этого листа в вершину, которая является *первым элементом* кода `P`.
    3.  Удалите найденный лист из списка `L` и первый элемент из кода `P`.
3.  Когда код `P` станет пуст, в списке `L` останется ровно две вершины. *Проведите ребро* между этими двумя вершинами.

*Важность и следствия:*
Поскольку алгоритмы кодирования и декодирования взаимно обратны, между множеством всех помеченных деревьев на `n` вершинах и множеством всех последовательностей длиной `n-2` (где каждый элемент — число от 1 до `n`) существует *биекция*. Количество таких последовательностей равно `n^(n-2)`. Таким образом, мы получаем знаменитую *формулу Кэли*:

Более подробно про коды Прюфера можно прочитать #link("https://neerc.ifmo.ru/wiki/index.php?title=%D0%9A%D0%BE%D0%B4%D1%8B_%D0%9F%D1%80%D1%8E%D1%84%D0%B5%D1%80%D0%B0")[тут]


== Количество остовных деревьев в ориентированном графе 

Это обобщение матричной теоремы о деревьях (теоремы Кирхгофа) на случай ориентированных графов.

*Определения (уточнённые):*

1.  *Ориентированное дерево (дерево с корнем, или ветвление):* Это ориентированный граф, у которого:
    -   Есть ровно одна вершина (корень), в которую не входит ни одно ребро (полустепень захода = 0).
    -   В каждую другую вершину входит ровно одно ребро (полустепень захода = 1).
    -   В графе нет ориентированных циклов.

2.  *Ориентированное остовное дерево с корнем в `r`:* Это подграф ориентированного графа `G`, который включает все его вершины, является ориентированным деревом и имеет корень `r`.

*Замечание:* Действительно, для одного графа может существовать несколько остовных деревьев с разными корнями. Количество таких деревьев зависит от выбранной корневой вершины `r`.

#theorem(name:[Теорема (Матричная теорема о деревьях для ориентированных графов, вариант Тута/Ботт-Мэйберла)], body:[
Количество остовных деревьев с корнем в заданной вершине `r` можно вычислить с помощью модифицированной матрицы Кирхгофа.

*Алгоритм:*

1.  Постройте *матрицу Кирхгофа* `L` размера `n x n` (где `n` — число вершин в графе) следующим образом:
    -   Для каждой вершины `i` вычислите ее *полустепень захода* `deg⁻(i)` (количество рёбер, входящих в `i`).
    -   На диагонали `L[i][i]` поставьте `deg⁻(i)`.
    -   Для недиагональных элементов `L[i][j]` (где `i != j`) поставьте *минус* количество рёбер, идущих *из `j` в `i`*. Обратите внимание на порядок индексов!

2.  Чтобы найти количество остовных деревьев с корнем в вершине `r`, нужно:
    1.  *Удалить строку и столбец*, соответствующие корню `r`, из матрицы `L`. Получится матрица `L_r` размера `(n-1) x (n-1)`.
    2.  Вычислить *определитель* матрицы `L_r`.

> Количество остовных деревьев с корнем в `r` = `det(L_r)`
])

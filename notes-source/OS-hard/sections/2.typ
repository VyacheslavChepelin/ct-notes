= Лекция 2

== Общая структура кода ядра Линукса

- Язык: Преимущественно C, с минимальными вставками ассемблера для критичных по производительности или низкоуровневых архитектурно-зависимых операций.

- В основном драйвера много места занимают.

Основные директории:

- arch/ (Архитектурно-зависимый код): Содержит поддиректории для каждой поддерживаемой архитектуры (x86, ARM, AARCH64 и т.д.). Включает код инициализации, обработку прерываний, низкоуровневые функции (например, memcpy), управление виртуальной памятью.

- kernel/ (Ядро ОС): Основные подсистемы: планировщик (sched/), управление процессами, системные вызовы, таймеры, синхронизация (locking/).

- mm/ (Управление памятью): Реализация виртуальной памяти, аллокаторы, подкачка.

- drivers/ (Драйверы устройств): Все драйверы, организованные по типу устройств (сеть, USB, ввод/вывод и т.д.).

- fs/ (Файловые системы): Виртуальная файловая система (VFS) и реализации конкретных ФС (ext4, NTFS, procfs).

- net/ (Сетевой стек): Реализация сетевых протоколов (IPv4/IPv6, TCP, UDP, Ethernet).

- ipc/ (Межпроцессное взаимодействие): Реализация механизмов IPC (System V, POSIX).

- include/ (Заголовочные файлы).

== Управление процессами в ОС

Процесс — это программа в момент выполнения. Абстракция, инкапсулирующая ресурсы.

Ресурсы процесса:

- Адресное пространство.

- Открытые файлы и файловые дескрипторы.

- Точка выполнения (одна или несколько).

- Сигналы, права доступа, сокеты и т.д.

Реализация в Linux: Процессы и потоки представлены структурой struct task_struct (дескриптор задачи/процесса). Эта структура содержит всю информацию о процессе: состояние, идентификатор (PID), указатели на ресурсы (память, файлы), приоритет планирования и т.д.


todo: отличие потока от процесса

== Управление памятью в ОС

Физическая память: Ядро управляет оперативной памятью через "Buddy Allocator", который борется с фрагментацией, выделяя память блоками кратных степеням двойки.

Виртуальная память: Каждый процесс работает в своем изолированном виртуальном адресном пространстве.

Страничная организация (Paging): Виртуальная память делится на страницы, которые отображаются на фреймы физической памяти.

Подкачка (Swapping): "Холодные" страницы могут быть вытеснены на диск (в swap-раздел), чтобы освободить оперативную память.

Отложенная загрузка (Demand Paging): Страницы загружаются в память только при первом обращении к ним.

Копирование при записи (Copy-on-Write, CoW): Механизм, используемый при fork(), когда страницы памяти между родителем и потомком разделяются до тех пор, пока один из процессов не попытается изменить их, что приводит к созданию физической копии.

Аллокаторы памяти:

- Для ядра: SLAB / SLUB аллокаторы (надстройки над Buddy Allocator) для эффективного выделения мелких объектов.

- vmalloc(): Выделяет виртуально непрерывную, но физически разрозненную память. Подходит для больших объемов, где не критична производительность TLB.

- Для пользователя: Системные вызовы brk(), mmap().

== Виртуальная файловая система и управление блочным вводом-выводом

TODO: более подробно и не занудно расписать 

VFS — это слой абстракции между ядром и конкретными файловыми системами (ext4, Btrfs, FAT). Она предоставляет унифицированный API для операций с файлами (open, read, write, close).

Основные структуры VFS:

- superblock: Представляет смонтированную файловую систему.

// на лекции он говорит information node, кому верить?
- inode (index node): Представляет объект в ФС (файл, директорию, симлинк). Содержит метаданные и указатели на блоки данных.

- dentry (directory entry): Представляет запись в директории, связывает имя файла с inode. Кэшируется для ускорения путей.

- file: Представляет открытый файл, связанный с процессом. Содержит позицию в файле и указатели на операции.

Блочный Input/Output:

- Запросы на чтение/запись от ФС попадают в I/O scheduler, который оптимизирует порядок операций для уменьшения времени позиционирования головок диска (например, CFQ, Deadline, NOOP).

- Оптимизированные запросы объединяются в структуру struct bio и отправляются на уровень драйвера блочного устройства.

// todo: более человечно расписать про жэто



== Сетевой стэк в Линуксе

Многоуровневая реализация сетевых протоколов.

Восходящий поток (Receive Path):

1. Сетевой адаптер через прерывание или NAPI ( polling ) передает пакет в драйвер.

2. Пакет помещается в структуру struct sk_buff (socket buffer) или сокет — основная структура данных для работы с сетевыми пакетами. Сокет - абстракция сетевого стека

3. Обработка на уровне Link (Ethernet), затем Network (IP).

4. Маршрутизация: ядро решает, предназначен ли пакет локальной системе, нужно ли его форвардить или отбросить.

5. На уровне Transport (TCP/UDP) пакет помещается в соответствующий сокет.

todo: отличие TCP, UDP

6. Приложение читает данные из сокета через системный вызов.

Нисходящий поток (Transmit Path): Движение в обратном порядке: сокет -> TCP/UDP -> IP -> Ethernet -> драйвер сетевой карты.

todo: вставитьб картинку из презентации

todo: NetFilter


== Драйверы устройств в архитектуре Линукса

Унифицированная модель устройств: Ядро предоставляет единый каркас для представления устройств, их шин, драйверов и классов.

Типы драйверов:

- Драйверы символьных устройств: Прямой доступ к данным (например, клавиатура, мышь, /dev/random).

- Драйверы блочных устройств: Доступ через буферизацию и кэширование, блоками (например, жесткие диски, SSD).

- Сетевые драйверы: Работают с сетевыми интерфейсами, оперируют пакетами (sk_buff), не имеют файлового представления в /dev.

- Интерфейсы: Каждая подсистема (USB, PCI, I2C) определяет свой стандартный интерфейс, который должен реализовать драйвер.

== Процессы и потоки

Процесс: Инстанс программы с собственными ресурсами (память, файлы).

Поток (Thread): Поток выполнения внутри процесса. Все потоки одного процесса разделяют его ресурсы (память, файловые дескрипторы), но имеют собственные стеки и регистры.

Реализация в Linux: Потоки реализованы как "легковесные процессы" (Lightweight Processes, LWP). Ядро видит и процессы, и потоки как задачи (tasks), представленные struct task_struct. Разница в том, на какие ресурсы они указывают.

TODO: более подробно

== Переключение контекста и миграция задач по ядрам процессора



== Контекст процесса
== Доступ к текущему процессу
== Блокирование и пробуждение
== Вытеснение задач в терминах контекста процесса
== Системный вызов clone()

Низкоуровневый системный вызов для создания нового потока выполнения.

Ключевая особенность: Принимает флаги, которые определяют, какие ресурсы будут разделяться с родительским процессом, а какие будут скопированы/изолированы.

- CLONE_VM: Потоки разделяют адресное пространство.

- CLONE_FILES: Потоки разделяют таблицу файловых дескрипторов.

- CLONE_FS: Потоки разделяют информацию о ФС (root, current directory).

- CLONE_SIGHAND: Потоки разделяют таблицу обработчиков сигналов.

fork() реализован как вызов clone() без флагов разделения.

pthread_create() реализован как вызов clone() с флагами разделения большинства ресурсов.

== Пространства имен и контейнеры

Пространства имен (Namespaces) — механизм изоляции глобальных системных ресурсов для группы процессов. Процессы в разных неймспейсах видят разные наборы ресурсов.

Основные типы неймспейсов:

- PID: Изоляция дерева процессов.

- Network: Изоляция сетевых интерфейсов, таблиц маршрутизации, портов.

- Mount (mnt): Изоляция точек монтирования.

- UTS: Изоляция hostname и domainname.

- IPC: Изоляция объектов System V IPC и POSIX message queues.

- User: Изоляция UID/GID.

- Cgroup: Изоляция корня cgroup.

Контейнеры (Docker, LXC) — это, по сути, изолированная группа процессов, достигнутая за счет комбинации неймспейсов и cgroups (для ограничения ресурсов).

